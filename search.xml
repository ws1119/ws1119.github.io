<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web API]]></title>
    <url>%2F2019%2F08%2F09%2FWeb-API%2F</url>
    <content type="text"><![CDATA[Web APIWeb API介绍API的概念API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 任何开发语言都有自己的API API的特征输入和输出(I/O) var max = Math.max(1, 2, 3); API的使用方法(console.log(‘adf’)) Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) 此处的Web API特指浏览器提供的API(一组方法)，Web API在后面的课程中有其它含义 掌握常见浏览器提供的API的调用方式MDN-Web API JavaScript的组成 ECMAScript - JavaScript的核心定义了JavaScript 的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 DOMDOM的概念文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本，更新其内容、结构和www文档的风格(目前，HTML和XML文档是通过说明部分定义的)。文档可以进一步被处理，处理的结果可以加入到当前的页面。DOM是一种基于树的API文档，它要求在处理过程中整个文档都表示在存储器中。 DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 DOM经常进行的操作 获取元素 对元素进行操作(设置其属性或调用其方法) 动态创建元素 事件(什么时机做相应的操作) 获取页面元素为什么要获取页面元素例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 根据id获取元素1234var div = document.getElementById('main');console.log(div);// 获取到的数据类型 HTMLDivElement，对象都是有类型的 注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。 根据标签名获取元素12345var divs = document.getElementsByTagName('div');for (var i = 0; i &lt; divs.length; i++) &#123; var div = divs[i]; console.log(div);&#125; 根据name获取元素*12345var inputs = document.getElementsByName('hobby');for (var i = 0; i &lt; inputs.length; i++) &#123; var input = inputs[i]; console.log(input);&#125; 根据类名获取元素*12345var mains = document.getElementsByClassName('main');for (var i = 0; i &lt; mains.length; i++) &#123; var main = mains[i]; console.log(main);&#125; 根据选择器获取元素*12345678var text = document.querySelector('#text');console.log(text);var boxes = document.querySelectorAll('.box');for (var i = 0; i &lt; boxes.length; i++) &#123; var box = boxes[i]; console.log(box);&#125; 总结 12345678掌握 getElementById() getElementsByTagName()了解 getElementsByName() getElementsByClassName() querySelector() querySelectorAll() 事件事件：触发-响应机制 事件三要素 事件源:触发(被)事件的元素 事件名称: click 点击事件 事件处理程序:事件触发后要执行的代码(函数形式) 事件的基本使用1234var box = document.getElementById('box');box.onclick = function() &#123; console.log('代码会在box被点击后执行'); &#125;; 案例 点击按钮弹出提示框 点击按钮切换图片 属性操作非表单元素的属性href、title、id、src、className 123456var link = document.getElementById('link');console.log(link.href);console.log(link.title);var pic = document.getElementById('pic');console.log(pic.src); 案例： ​ 点击按钮显示隐藏div ​ 美女相册 innerHTML和innerText 12345var box = document.getElementById('box');box.innerHTML = '我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;';console.log(box.innerHTML);box.innerText = '我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;';console.log(box.innerText); HTML转义符 1234567&quot; &amp;quot;&apos; &amp;apos;&amp; &amp;amp;&lt; &amp;lt; // less than 小于&gt; &amp;gt; // greater than 大于空格 &amp;nbsp;© &amp;copy; innerHTML和innerText的区别 innerText的兼容性处理 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 案例 点击按钮禁用文本框 给文本框赋值，获取文本框的值 检测用户名是否是3-6位，密码是否是6-8位，如果不满足要求高亮显示文本框 设置下拉框中的选中项 搜索文本框 全选反选 自定义属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 与element.属性的区别: 上述三个方法用于获取任意的行内属性。 样式操作 使用style方式设置的样式显示在标签行内 1234var box = document.getElementById('box');box.style.width = '100px';box.style.height = '100px';box.style.backgroundColor = 'red'; 注意 通过样式属性设置宽高、位置的属性类型是字符串，需要加上px 类名操作 修改标签的className属性相当于直接修改标签的类名 12var box = document.getElementById('box');box.className = 'show'; 案例 开关灯 点击按钮变色 图片切换二维码案例 当前输入的文本框高亮显示 点击按钮改变div的大小和位置 列表隔行变色、高亮显示 京东商品展示 tab选项卡切换 创建元素的三种方式document.write()1document.write('新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;'); innerHTML12var box = document.getElementById('box');box.innerHTML = '新内容&lt;p&gt;新标签&lt;/p&gt;'; document.createElement()12var div = document.createElement('div');document.body.appendChild(div); 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 案例 动态创建列表，高亮显示 根据数据动态创建表格 模拟百度搜索文本框 节点操作1234567891011var body = document.body;var div = document.createElement('div');body.appendChild(div);var firstEle = body.children[0];body.insertBefore(div, firstEle);body.removeChild(firstEle);var text = document.createElement('p');body.replaceChild(text, div); 案例： ​ 权限选择 节点属性模拟文档树结构 12345678910111213141516171819202122232425262728293031323334353637383940function Element(option) &#123; this.id = option.id || ''; this.nodeName = option.nodeName || ''; this.nodeValue = option.nodeValue || ''; this.nodeType = 1; this.children = option.children || [];&#125;var doc = new Element(&#123; nodeName: 'html'&#125;);var head = new Element(&#123; nodeName: 'head'&#125;);var body = new Element(&#123; nodeName: 'body'&#125;)doc.children.push(head);doc.children.push(body);var div = new Element(&#123; nodeName: 'div', nodeValue: 'haha',&#125;);var p = new Element(&#123; nodeName: 'p', nodeValue: '段落'&#125;)body.children.push(div);body.children.push(p);function getChildren(ele) &#123; for(var i = 0; i &lt; ele.children.length; i++) &#123; var child = ele.children[i]; console.log(child.nodeName); getChildren(child); &#125;&#125;getChildren(doc); 节点层级重点讲父子属性，兄弟属性画图讲解 12345678var box = document.getElementById('box');console.log(box.parentNode);console.log(box.childNodes);console.log(box.children);console.log(box.nextSibling);console.log(box.previousSibling);console.log(box.firstChild);console.log(box.lastChild); 注意 childNodes和children的区别，childNodes获取的是子节点，children获取的是子元素 nextSibling和previousSibling获取的是节点，获取元素对应的属性是nextElementSibling和previousElementSibling获取的是元素 ​ nextElementSibling和previousElementSibling有兼容性问题，IE9以后才支持 总结 1234567891011节点操作，方法 appendChild() insertBefore() removeChild() replaceChild()节点层次，属性 parentNode childNodes children nextSibling/previousSibling firstChild/lastChild 事件详解注册/移除事件的三种方式123456789101112131415var box = document.getElementById('box');box.onclick = function () &#123; console.log('点击后执行');&#125;;box.onclick = null;box.addEventListener('click', eventCode, false);box.removeEventListener('click', eventCode, false);box.attachEvent('onclick', eventCode);box.detachEvent('onclick', eventCode);function eventCode() &#123; console.log('点击后执行');&#125; 兼容代码12345678910111213141516171819function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent)&#123; element.attachEvent('on' + type,fn); &#125; else &#123; element['on'+type] = fn; &#125;&#125;function removeEventListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, fn); &#125; else &#123; element['on'+type] = null; &#125;&#125; 事件的三个阶段 捕获阶段 当前目标阶段 冒泡阶段 事件对象.eventPhase属性可以查看事件触发时所处的阶段 事件对象的属性和方法 event.type 获取事件类型 clientX/clientY 所有浏览器都支持，窗口位置 pageX/pageY IE8以前不支持，页面位置 event.target || event.srcElement 用于获取触发事件的元素 event.preventDefault() 取消默认行为 案例 跟着鼠标飞的天使 鼠标点哪图片飞到哪里 获取鼠标在div内的坐标 阻止事件传播的方式 标准方式 event.stopPropagation(); IE低版本 event.cancelBubble = true; 标准中已废弃 常用的鼠标和键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按键按下触发 onkeydown 键盘按键抬起触发 BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 alert() prompt() confirm() 页面加载事件 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&#125; onunload 123window.onunload = function () &#123; // 当用户退出页面时执行&#125; 定时器setTimeout()和clearTimeout()在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () &#123; console.log('Hello World');&#125;, 1000);// 取消定时器的执行clearTimeout(timerId); setInterval()和clearInterval()定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数 12345678// 创建一个定时器，每隔1秒调用一次var timerId = setInterval(function () &#123; var date = new Date(); console.log(date.toLocaleTimeString());&#125;, 1000);// 取消定时器的执行clearInterval(timerId); location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个&apos;/&apos;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用&apos;&amp;&apos;符号隔开，每个参数的名和值用&apos;=&apos;符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… 案例解析URL中的query，并返回对象的形式 1234567891011121314151617function getQuery(queryStr) &#123; var query = &#123;&#125;; if (queryStr.indexOf('?') &gt; -1) &#123; var index = queryStr.indexOf('?'); queryStr = queryStr.substr(index + 1); var array = queryStr.split('&amp;'); for (var i = 0; i &lt; array.length; i++) &#123; var tmpArr = array[i].split('='); if (tmpArr.length === 2) &#123; query[tmpArr[0]] = tmpArr[1]; &#125; &#125; &#125; return query;&#125;console.log(getQuery(location.search));console.log(getQuery(location.href)); history对象 back() forward() go() navigator对象 userAgent 通过userAgent可以判断用户浏览器的类型 platform 通过platform可以判断浏览器所在的系统平台类型. 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别 123456var box = document.getElementById('box');console.log(box.offsetParent);console.log(box.offsetLeft);console.log(box.offsetTop);console.log(box.offsetWidth);console.log(box.offsetHeight); 客户区大小12345var box = document.getElementById('box');console.log(box.clientLeft);console.log(box.clientTop);console.log(box.clientWidth);console.log(box.clientHeight); 滚动偏移12345var box = document.getElementById('box');console.log(box.scrollLeft)console.log(box.scrollTop)console.log(box.scrollWidth)console.log(box.scrollHeight)]]></content>
      <tags>
        <tag>Web API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类定义包含抽象方法的类：通常在有继承关系的类之间，父类对子类的行为没有强制的约束，但是有时候要求子类必须实现父类的方法，这时抽象类可以实现 抽象类:在类的基础上定义了抽象方法的类，抽象方法是指用abstract修饰的方法，没有方法体{} 抽象方法：使用abstract关键字修饰的方法，抽象方法只包含有一个方法名，不包含方法体。定义格式：修饰符 abstract 返回值类型 方法名（参数列表） 一个类汇中如果包含抽象方法，那么这个类必须是抽象类 抽象类的基本定义： 抽象类不能用final修饰，抽象类中可以有：普通方法、静态方法、抽象方法 抽象类中可以有构造方法，如果在抽象父类中，明确定义了有参的构造方法，子类要使用父类的构造方法，父类是抽象类，不能被实例化必须用super（）去调用 抽象类中允许没有任何的抽象方法定义，只要类有abstract修饰，一样抽象类也不能直接别实例化 如果要一个类（他要求有完整的功能定义），但他又不能直接被使用，他必须有子类才能使用 子类对象在实例化之前，一定要先调用父类构造，在调用子类构造 抽象类使用向上自动转型，把一个子类的类型可以转化成一个父类的类型 示例： 12345678910111213141516171819202122232425262728抽象模板父类：行为的抽象，不同的子类可以表现不同的行为：抽象模板父类：public static final int EAT = 1; public static final int SLEEP = 2; public static final int WORK = 3; public final void command(int cmd) &#123; switch (cmd) &#123; case EAT : this.eat(); break; case SLEEP : this.sleep(); break; case WORK: this.work(); break; case EAT + SLEEP + WORK: this.eat(); this.sleep(); this.work(); break; default: break; &#125; &#125; public abstract void eat(); public abstract void sleep(); public abstract void work(); 123456789101112131415子类二：public class Pig extends AbstractModul &#123; @Override public void eat() &#123; System.out.println("猪在抢食"); &#125; @Override public void sleep() &#123; System.out.println("猪在睡觉"); &#125; @Override public void work() &#123; System.out.println("猪不工作"); &#125;&#125; 123456789101112131415子类三：public class Robat extends AbstractModul &#123; @Override public void eat() &#123; System.out.println("机器人在加油"); &#125; @Override public void sleep() &#123; System.out.println("机器人不睡觉"); &#125; @Override public void work() &#123; System.out.println("机器人在打工"); &#125;&#125; 抽象类使用原则 抽象类本身不完善，就是一个半成品，不能直接实例化对象；抽象类必须有子类来继承 子类如果不是抽象类，他必须复写中抽象类中的全部抽象方法 抽象类可以依靠子类的对象向上转型实现实例化对象定义，即调用到被子类复写的方法为啥不能被实例化：当类比赛实例化对象时，需要有分配内存空间，同时该对象可以调用类中的方法，但是抽象方法是没有方法体的，所以无法调用； 总结：在设计中，如果必须强制子类重写的方法就调用抽象方法定义，就能做出父类标准]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC编程]]></title>
    <url>%2F2019%2F07%2F25%2FJDBC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JDBC编程概述jdbc是java数据库连接(Java DataBase connnectivity)技术的简称，由一组使用java语言编写的类和接口组成，可以为多种数据库提供统一访问 Driver接口又数据库厂家提供 导包在编程中要连接数据库，就必须先装载数据库驱动程序，不同数据库有不同的装载方法： Mysql:Class.forName(“com.mysql.jdbc.Driver”) Oralce:Class.forName(“oracle.jdbc.driver.OracleDriver”) SQL Server:Class.forName(“com.microsoft.jdbc.sqlserver.SQLServerDriver”) sybase:Class.forName(“com.sybase.jdbc.sybDriver”) 驱动管理(DriverManager接口)是Jdbc的管理层，作用于用户和驱动之间。程序使用该类书要是用于获取collection对象 连接接口(collection接口和DriverManager接口创建)collection接口连接数据库，在连接上下文中执行SQL语句并返回结果 collection代表数据库连接对象，每一个collection代表一个物理连接会话，想要访问数据库就必须先的到数据库连接 Java中几种常见数据库连接方法： oracle： 1234private static final String driver=&quot;oracle.jdbc.driver.OracleDriver&quot;//连接oracle的驱动程序类private static final url=&quot;jdbc:oracle:thin:@i地址:1521:orcl&quot;//连接oracle的连接字符串private static final user=&quot;scott&quot;//登录数据库用户名private static final password=&quot;tiger&quot;//登录库密码 MySQL: 12345String Dirver="com.mysql.jdbc.Driver";//驱动程序String URL="jdbc:mysql://localhost:3306/db_name"; //连接的URL,db_name为数据库名String UserName="username"; //用户名String Password="password"; //密码Class.forName(Driver).newInstance(); //加载数据库驱动 Microsoft SQL server: 1234567String Driver="com.microsoft.jdbc.sqlserver.SQLServerDriver"; //驱动程序String URL="jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=db_name"; //连接的URL,db_name为数据库String UserName="username"; //用户名String Password="password"; //密码Class.forName(Driver).newInstance();connection con=DriverManager.getConnection(URL,Username,Password); sybase: 12345String Driver="com.sybase.jdbc.sybDriver"; //驱动程序String URL="jdbc:Sybase://localhost:5007/db_name"; //连接的URL,db_name为数据库String UserName="username"; //用户名 String Password="password"; //密码Class.forName(Driver).newInstance(); JDBC编程实现步骤加载数据库驱动，通常使用Class类的forName静态方法来加载驱动 Class.foName(driverclass),driverclass就是数据库驱动类所对应的的字符串 通过DriverManager获取数据库连接 查询数据库，取得结果集 数据库的执行数据库的增、删、改 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class DBHElper &#123; public static Connection con = null; public static Statement ss = null;// 编译对象 private static PreparedStatement ps = null;// 预编译对象 private static ResultSet rs = null; private static final String driver = "oracle.jdbc.driver.OracleDriver"; private static final String url = "jdbc:oracle:thin:@192.168.64.128:1521:orcl"; private static final String user = "scott"; private static final String password = "tiger"; static &#123; // 1.加载数据库驱动，通过Class类的forName()静态方法 try &#123; Class.forName(driver); &#125; catch (ClassNotFoundException e) &#123; System.out.println("加载数据库驱动失败"); &#125; &#125; /** * * @Title: getConnection * @Description: TODO(取得数据库连接) * @param: @return * @return: Connection 数据库连接对象 * @throws */ public static Connection getConnection() &#123; try &#123; return DriverManager.getConnection(url, user, password); &#125; catch (Exception e) &#123; System.out.println("取得数据库连接失败"); &#125; return null; &#125; /** * * @Title: execute * @Description: TODO(执行查询) * @param: @param sql SQL语句 * @param: @param paraments 参数数组 * @param: @param con 数据库连接对象 * @param: @return * @return: ResultSet 结果集 * @throws */ // 查询数据库，取得结果集：ResultSet public static ResultSet execute(String sql, Object[] paraments,Connection con) &#123; // 创建一个预编译对象 try &#123; con=getConnection(); ps = con.prepareStatement(sql); if (paraments != null) &#123; for (int i = 0; i &lt; paraments.length; i++) &#123; // 给预编译对象中的SQL语句添加参数 ps.setObject(i + 1, paraments[i]); &#125; &#125; // 执行查询取得数据库数据 rs = ps.executeQuery(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;//此处不能关闭数据库连接，用完数据请关闭连接 return rs; &#125; /** * * @Title: execute1 * @Description: TODO(数据库的执行数据的增、删、改) * @param: @param sql SQL语句 * @param: @param paraments 参数数组 * @param: @param con 数据库连接对象 * @param: @return * @return: int 影响表中的行数 * @throws */ public static int execute1(String sql, Object[] paraments, Connection con) &#123; // 影响的行数 int rows = -1; try &#123; ps = con.prepareStatement(sql); if (paraments != null) &#123; for (int i = 0; i &lt; paraments.length; i++) &#123; // 给预编译对象中的SQL语句添加参数 ps.setObject(i + 1, paraments[i]); &#125; &#125; // 执行更新返回影响数据表的行数 rows = ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ps.close(); con.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return rows; &#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public static void main(String[] args) &#123; select(); updatedelete(); &#125; public static void select() &#123; //取得连接对象 //TestJDBC.testStatement(con); // 查询数据库////////////////////////////////////测试preparedStatementer的查询功能/////////////////////////////////////// //在DBhelper类的外部随时可以取得数据库连接 Connection con = DBHElper.getConnection(); String sql="select *from emp "; //Object[] paraments = new Object[] &#123;7369&#125;; ResultSet rs=DBHElper.execute(sql, null,con); //遍历结果集 try &#123; Emp empObj = null; List&lt;Emp&gt; emps =new ArrayList&lt;&gt;(); while(rs.next()) &#123; //从结果集去取出数据，按照sql语句中列的顺序一次去除，注意表中每一列的数据类型必须与java代码中接受的类型保持一致 /*Integer empNo = rs.getInt(1);//resultSet取表中列是从1开始的 String eName = rs.getString(2); String eJob = rs.getString(3); Integer eMger = rs.getInt(4); Date hdate = rs.getDate(5); Integer sal = rs.getInt(6); Integer com = rs.getInt(7); Integer deptNO = rs.getInt(8);*/ empObj = new Emp(); empObj.setEmpNo( rs.getInt("EMPNO"));//也可以写表的列名 empObj.seteName(rs.getString(2)); empObj.seteJob(rs.getString(3)); empObj.seteMge(rs.getInt(4)); empObj.setHdate(rs.getDate(5)); empObj.setSal(rs.getInt(6)); empObj.setCom(rs.getInt(7)); empObj.setDeptNO(rs.getInt(8)); emps.add(empObj); //System.out.println(empObj); &#125; for (Emp emp : emps) &#123; System.out.println(emp); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; //先关闭预编译对象。再关闭连接 rs.close(); con.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //测试preparedStatementer的更新功能 public static void updatedelete() &#123;////////////////////////////////////测试preparedStatementer的更新功能/////////////////////////////////////// /** * 对于多条数据集更新，必须用事务才能保证数据完整，connection对象是默认事务 */ // 取得连接对象 Connection con1 = DBHElper.getConnection(); String addSql = "insert into emp(empno,ename,sal,deptno) values(?,?,?,?)"; String updatesql = "update emp set sal = sal+100 where empno=?"; String delsql = "delete from emp where empno = ?"; Object[] paraments1 = new Object[] &#123; 1000, "hjg", 4500, 30 &#125;; Object[] paraments2 = new Object[] &#123;1000&#125;; Object[] paraments3 = new Object[] &#123;1000&#125;; if (DBHElper.execute1(updatesql, paraments2, con1) &gt; 0) &#123; System.out.println("修改数据成功"); &#125; &#125; Statemnet和PrepareStatement区别 1.Statement支持批处理，但是要求SQL语句必须update类型语句，不能设置参数，性能低 2.PrepareStatement可以 预处理，批处理，延迟加载性能高，支持设置多个参数 使用Statement对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 // 使用statement对象，批处理多条SQL语句 public static void testStatement(Connection con) &#123; try &#123; // 创建statement对象，取得编译对象 ss = con.createStatement(); // ss.addBatch(sql);//sql:select *from emp where empno=7369; // 增加参数 String sql1 = "update emp set sal= sal +10000 where empno=7369"; String sql2 = "update emp set sal = sal + 500 where empno=7499"; String sql3 = "delete from emp where empno=1234"; System.out.println("==================="); // statements有批处理更新功能（包括插入数据，修改数据，删除数据） ss.addBatch(sql1); ss.addBatch(sql2); ss.addBatch(sql3); // 执行查询 int roes[] = ss.executeBatch();// 表示执行每一条SQL语句成功后影响的数据行数 for (int i = 0; i &lt; roes.length; i++) &#123; System.out.println(roes[i]); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;/*public static void test() &#123; Connection con = TestJDBC.getConnection(); ResultSet rSet = TestJDBC.execute(null, null, con); // 使用结果集打印输出 try &#123; while (rSet.next()) &#123;// 如果结果集有数据行，next()返回true // 把所查询的表的列的类型与java做一对一翻译 Integer empNO = rSet.getInt(1);// 结果集第一列从1开始写 String eName = rSet.getString(2); String eJob = rSet.getString(3); Integer emagnger = rSet.getInt(4); Date hDate = rSet.getDate(5); System.out.println("员工编号" + empNO + "姓名" + eName + "职位" + eJob + "上司编号" + emagnger + "入职时间" + hDate); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; rSet.close(); con.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;*/]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O流]]></title>
    <url>%2F2019%2F07%2F24%2FI-O%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O流流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作 分类 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 缓冲流也叫高效流，基本原理是，在创建对象时，会创建一个内置的默认大小的缓冲区，通过缓冲区读写，减少系统IO次数，从而提高读写的效率 流对象 输入字节流InputStreamInputStream 是所有的输入字节流的父类，它是一个抽象类。ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。FileInputStream类可以通过一个String路径名创建一个对象，FileInputStream(String name) 示例: 123456789101112131415public static void main(String[] args) &#123; File file=new File("F:\\filetest\\a.txt"); FileInputStream fis=null; try &#123; fis = new FileInputStream(file); byte data[]=new byte[(int)file.length()]; int len =fis.read(data); System.out.println(new String(data,0,len)); &#125; catch (Exception e) &#123; &#125;finally&#123; fis.close(); &#125; &#125; 输出字节流OutputStreamOutputStream 是所有的输出字节流的父类，它是一个抽象类。ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。 示例： 1234567891011121314151617181920File file=new File("F:\\filetest\\a.txt"); FileInputStream fis=null; //写入磁盘 FileOutputStream fos=null; try &#123; fos = new FileOutputStream(file); String str="中华人民共和国"; byte[] b=str.getBytes(); fos.write(b,0,b.length); fos.write(555); fos.write(b,3,15); &#125; catch (Exception e) &#123; &#125;finally &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; &#125; &#125; 字符输入流ReaderReader 是所有的输入字符流的父类，它是一个抽象类。 CharReader、StringReader是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。 InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。 示例： 1234567891011121314File file=new File("F:\\filetest\\b.txt"); FileReader fr=null; try &#123; fr=new FileReader(file); int b; char[] cbuf=new char[50]; while((b=fr.read(cbuf))!=-1) &#123; //System.out.print((char)b); System.out.print(new String(cbuf,0,b)); fr.close(); &#125; &#125; catch (Exception e) &#123; e.getStackTrace(); &#125; 字符输出流WriterWriter 是所有的输出字符流的父类，它是一个抽象类。 CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。 PipedWriter 是向与其它线程共用的管道中写入数据， 示例： 123456789101112131415File file1=new File(&quot;F:\\filetest\\b.txt&quot;); try &#123; FileWriter fw = new FileWriter(file1); String string=&quot;中华人民共和国&quot;; char charray[]=string.toCharArray(); fw.write(charray); fw.write(&apos;\r&apos;); fw.write(66666); fw.write(&quot;中和共和国&quot;); fw.flush();//这个方法不是关闭流，有什么作用: fw.close(); &#125; catch (Exception e) &#123; &#125; 字节缓冲流构造方法： public BufferedInputStream(InpuStream in):创建一个新的缓冲输入流 public BufferedOutputStream(OupuStream out):创建一个新的缓冲输出流 示例： 1234567891011121314public static void bufferdIOStream() throws Exception &#123;BufferedInputStream fis=new BufferedInputStream(new FileInputStream("F:\\filetest\\jdk-8u181-windows-x64.exe"));BufferedOutputStream fos=new BufferedOutputStream(new FileOutputStream("E:\\"));//读数据int b;long start=System.currentTimeMillis();while ((b=fis.read())!=-1) &#123; fos.write(b);&#125;long end=System.currentTimeMillis();System.out.println("结束时间："+end);System.out.println("执行时间："+((end-start)/1000)+"s"); &#125; 字符缓冲流构造方法： BufferedReader br=new BufferedReader(new FileReader(&quot;&quot;)):创建一个新的缓冲输入流 BufferedWriter bw=new BufferedWriter(new FileWriter(&quot;&quot;)):创建一个新的缓冲输出流 示例： 123456789101112public class Buffer_StringStream &#123; public static void buffer_RW() throws Exception&#123; BufferedReader br=new BufferedReader(new FileReader("")); BufferedWriter bw=new BufferedWriter(new FileWriter("")); String line=null; while((line=br.readLine())!=null) &#123; System.out.print(line); System.out.println("-----------"); bw.write(line); &#125; br.close(); &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归递归是指在当前方法内调用自己的这种现象 分类 直接递归：方法自身调用自己 间接递归：从A方法调用B方法，B方法调用C方法，C方法调用A方法 注意 递归一定要有条件限制，保证递归能够停止下来，否则会发生栈内存溢出 在递归中虽然有条件限制，但是递归次数不能太多，否则也会发生栈内存溢出 构造方法禁止递归 例子，打印多级目录 123456789101112131415161718192021222324public static void main(String[] args) &#123; printDir(new File("d:\\jdk1.8")); &#125; public static void printDir(File dir) &#123; File[] dFiles = dir.listFiles(); if (null == dFiles || dFiles.equals(null)) return;// 判断是否为空 for (File file : dFiles) &#123; if (file.isFile()) &#123; System.out.println("文件名绝对路径" + file.getAbsolutePath()); System.out.println("文件名" + file.getName()); // 文件大小 long filesize = file.length(); System.out.println(filesize + "byte" + filesize / 1024 + "kb" + "," + filesize / 1024 / 1024 + "m");// 字节 String exstr = file.getName().substring(file.getName().lastIndexOf(".") + 1, file.getName().length()); System.out.println("拓展名：" + exstr); &#125; else if (file.isDirectory()) &#123; System.out.println("目录名绝对路径" + file.getAbsolutePath()); System.out.println("目录名" + file.getName()); printDir(file); &#125; &#125; &#125; 打印出1-100的和 123456789101112131415public static void main(String[] args) &#123; funSum(1); System.out.println("sum="+sum);&#125;private static int sum = 0;public static void funSum(int i) &#123; sum += i; System.out.println("i=" + i); // 保证递归能够停下来，递归要有限制条件，否则会发生内存溢出 if (i == 100) &#123; return; &#125; i++; funSum(i);&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[File类]]></title>
    <url>%2F2019%2F07%2F24%2FFile%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[File类java.io.file类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找、和删除等操作 构造方法 public File(String pathname):通过将给定的路径名字符串转化为抽象路径名来创建新的File实例 public File(String parent,String child):从父路径名字字符串和子路径名字字符串创建新的File实例 public File(File parent,Stirng child):从抽象父路径名和子路径名字符串创建新的File实例 常用方法 获取功能的方法 public String getAbsoulutePath(): 返回此File的绝对路径名字字符串 public String getPath(): 将此File转换为路径名字字符串 public String getName(): 返回由此File表示的文件目录的名称 public long length() 返回由此File表示的文件的长度 判断功能的方法 public boolean exists(): 此File表示的文件或者目录是否实际存在 public boolean isDirectory(): 此File表示的是否为目录 public boolean isFile(): 此File表示的是否为文件 创建删除文件的功能 public boolean createNewFile(): 当且仅当有该名称的文件存在是，创建一个新的空文件 public boolean delete(): 删除由此File表示的文件或者目录 public boolean mkdir(): 创建由此File表示的目录 public boolean mkdirs(): 创建由此File表示的目录，包括任何必须但不存在的父目录 目录的遍历1234567891011121314151617File dDri = new File("d:\\jdk1.8"); // 获取当前目录下的文件夹和文件夹名称String[] dirs = dDri.list();for (String string : dirs) &#123; // 判断是文件或者目录，参数要用绝对路径 File file = new File(dDri.getAbsoluteFile() + "\\" + string); if (file.isDirectory()) System.out.println(string + "是目录"); else System.out.println(string + "是文件"); &#125;// 获取当前目录下的文件信息(包含目录和文件的完整目录信息)System.out.println("---------------------------------------");File[] dFiles = dDri.listFiles();for (File file : dFiles) &#123; System.out.println(file);&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B3%9B%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[泛型解决了向上向下转型带来的安全隐患，约束了参数的类型，在定义类的时候，对于类属性名，方法的参数不用指明哪一种参数，在使用的时候定义 关键字 通配符但我们使用泛型的时候，对于数据类型，在使用的时候无法确定，使用多种类型的时候，方法的重载搞不定，重载与泛型的重载类型不相关，在重载解决不了的时候，引出 泛型接口泛型接口是在定义时能够接受任何类型的接口，子类可以是一个泛型类，也可以是普通类；如果是普通类要指明实现接口的数据类型；使用泛型接口的时候，如果是普通类，则不能任意改变其泛型接口的类型 实例： 12345678910111213141516171819202122232425262728293031//定义一个泛型接口interface IMessage&lt;T&gt;&#123; //抽象方法 public abstract void print(T t);&#125;//在子类继续定义泛型class MessageImpl&lt;T&gt; implements IMessage&lt;T&gt;&#123; @Override public void print(T t) &#123; System.out.println(t); &#125;&#125;//子类不设置泛型，而在接口处直接实现具体泛型类型class MessageImpl2 implements IMessage&lt;String&gt;&#123; @Override public void print(String t) &#123; System.out.println(t); &#125;&#125;//main方法测试public class GInterface &#123; public static void main(String[] args) &#123; IMessage&lt;String&gt; ii= new MessageImpl &lt;String&gt;(); //泛型接口，子类实现出可以改变数据类型 IMessage&lt;Integer&gt; ii3= new MessageImpl &lt;Integer&gt;(); ii3.print(23); ii.print("hello world"); IMessage&lt;String&gt; ii2 = new MessageImpl2(); ii2.print("hello world"); &#125; 泛型接口使得我们的方法变得通用 泛型的上限下限 【类和方法】设置泛型上限（？extends类）：只能使用当前类的子类是指泛型类型；如：“？extends Number:可以设置Number或Number的子类，如double不能设置String 【方法】设置泛型下限（？ super类）：只能使用指定类或者父类设置泛型类型；如：“？ super String”:只能使用String类或Objects设置泛型类型 12345678910111213//【类和方法】设置泛型上限class Message1&lt;T extends Number&gt;&#123; private T msg; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; public void fun(Message1&lt;? extends Number&gt; temp) &#123; System.out.println(temp.getMsg()); &#125;&#125; 1234567891011121314//【方法】设置泛型上限class Message2&lt;T&gt;&#123; private T msg; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; //设置泛型下限 public void fun(Message2&lt;? super String&gt; temp) &#123; System.out.println(temp.getMsg()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射1.概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象，（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述） 2.使用2.1反射Class的使用:获取Class的三种方式 Object ——&gt;getClass()，即通过对象.getClass Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取 任何数据类型（包括基本数据类型）都有一个“静态的方法”的Class属性 通过Class类的静态方法：forName(String className)(常用) 示例： 12345678910111213//先定义一个Student类class Student&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; void testPring() &#123; System.out.println(""); &#125;&#125; 通过Object获得对象 1234Student stuObj = new Student();//产生一个student对象Class&lt;? extends Student&gt; stuClass = stuObj.getClass();System.out.println(stuClass.getName());//完整类型名System.out.println(stuClass.getSimpleName());//简单类型名 通过静态Class属性获得 1234Class&lt;?&gt; cls = cn.cuit.reflanctence.Student.class;System.out.println("全名"+cls.getName());System.out.println("类型名"+cls.getSimpleName());System.out.println(stuClass == cls);//判断第一种方式获取的class对象 通过Class类的静态方法 12345678910try &#123; Class&lt;Student&gt; stu = (Class&lt; Student&gt;) Class.forName("cn.cuit.reflanctence.Student"); //通过Class类的newinstance()可以得到对象 Student stuobj1 = stu.newInstance(); stuobj1.setName("张三"); stuobj1.testPring(); System.out.println(stuobj1.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 反射实例化对象 12345Class&lt;Student&gt; stu = (Class&lt; Student&gt;) Class.forName("cn.cuit.reflanctence.Student"); //通过Class类的newinstance()可以得到对象 Student stuobj1 = stu.newInstance(); stuobj1.setName("张三"); stuobj1.testPring(); 注意：在运行期间，一个类，只有一个Class对象产生。 三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 2.2反射调用构造方法利用反射器调用构造方法需要类中有默认构造方法，如果没有默认构造方法则需要通过反射调用指定类型的参数构造，实现实例化 Apple类 123456789101112131415161718192021222324252627282930313233343536class Apple&#123; private String name; private Integer weight; //封装 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; //默认构造 public Apple() &#123;&#125; //带参构造 public Apple(String name,Integer weight) &#123; this.name=name; this.weight=weight; &#125; @Override public String toString() &#123; return "Apple [name=" + name + ", weight=" + weight + "]"; &#125; //定义一个不带参的方法 public void print() &#123; System.out.println("苹果"+this.name+"重量是"+this.weight); &#125; //定义一个带参的方法 public void prin1t(String name,int weight) &#123; System.out.println("苹果"+this.name+"重量是"+this.weight); &#125;&#125; 测试类 1234567891011public class TestRef &#123; public static void main(String[] args) throws Exception &#123; //Class的类的实例调用getConstrcutor()取得类的构造器 Class&lt;?&gt; class1 = Class.forName("cn.cuit.ref.Apple"); //利用反射调用自定义构造方法 Constructor&lt;?&gt; ct = class1.getConstructor(String.class, Integer.class); //构造器.newinstance()取得具体的对象 Apple aplObj = (Apple) ct.newInstance("红富士", 20); System.out.println(aplObj); &#125;&#125; 结果： 1Apple [name=红富士, weight=20] 2.3反射调用普通方法12345678910//获取Class对象Class&lt;?&gt; cls = Class.forName("cn.cuit.ref.Apple");//获取不带参的print方法Method printMethod = cls.getMethod("print");//相当于调用方法printprintMethod.invoke(cls.newinstance);//获取带参的print1方法Method printMethod1 = cls.getMethod("print1",String.class,int.class);//调用带参的普通方法printMethod1.invoke(cls.newinstance,"sss",666) 2.4反射取得类成员类的成员包括： 从其他类继承而来的成员：public Field getField 本类中定义的成员：public Field getDeclareField 12345678910111213141516171819202122public class TestRef3 &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName("cn.cuit.reflanctence.Apple"); Object object = cls.newInstance(); Field field =cls.getDeclaredField("name"); /////////////////////////////////// Field[] fields = cls.getFields(); for(int i = 0 ; i &lt;fields.length;i++) &#123; System.out.println(fields[i].getName()); &#125; ///////////////////////////////////// //解除类成员变量的private的访问权限 field.setAccessible(true); //给对象赋值 field.set(object, "红苹果"); //取得对象属性的值 field.get(object); Method method =cls.getDeclaredMethod("print"); method.invoke(object); &#125;&#125; 使用declare的优点 2.6反射改造工厂12345678910111213141516171819202122232425262728293031323334353637383940414243//定义一个接口interface ILearn&#123; public abstract void learn();&#125;class Student implements ILearn&#123; @Override public void learn() &#123; System.out.println("学生在上课"); &#125;&#125;class Teacher implements ILearn&#123; @Override public void learn() &#123; System.out.println("老师在备课"); &#125;&#125;class Works implements ILearn&#123; @Override public void learn() &#123; System.out.println("工人在干工"); &#125;&#125;class SimpleFactory&#123; //创建对象 public static ILearn createInstance(String className) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(className); return(ILearn)cls.newInstance(); &#125;&#125;public class TestRefFactory &#123; public static void main(String[] args) &#123; ILearn stuZs = new Student(); stuZs.learn(); ILearn teLS = new Teacher(); teLS.learn(); ILearn wuWU = new Works(); wuWU.learn(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals方法重写]]></title>
    <url>%2F2019%2F07%2F21%2Fequals%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重写equals方法equals方法也是object类中的一个方法，调用object类就可以找到，是一个boolean类型的方法，用于比较两个对象是否相等 代码演示 123456789101112public boolean equals(Object obj) &#123; //判断对象地址是否相等，如果是就不用判断 if(this == obj) &#123; return false; &#125; 判断对象是否为空以及两个对象是否相等 if(obj == null || this.getClass() != obj.getClass()) &#123; return true; &#125; Equels equels = (Equels) obj; //判断成员变量 return age ==equels.age &amp;&amp; Objects.equals(getName(), equels.getName())]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
