<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[I/O流]]></title>
    <url>%2F2019%2F07%2F24%2FI-O%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O流流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作 分类 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 缓冲流也叫高效流，基本原理是，在创建对象时，会创建一个内置的默认大小的缓冲区，通过缓冲区读写，减少系统IO次数，从而提高读写的效率 流对象 输入字节流InputStreamInputStream 是所有的输入字节流的父类，它是一个抽象类。ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。FileInputStream类可以通过一个String路径名创建一个对象，FileInputStream(String name) 示例: 123456789101112131415public static void main(String[] args) &#123; File file=new File("F:\\filetest\\a.txt"); FileInputStream fis=null; try &#123; fis = new FileInputStream(file); byte data[]=new byte[(int)file.length()]; int len =fis.read(data); System.out.println(new String(data,0,len)); &#125; catch (Exception e) &#123; &#125;finally&#123; fis.close(); &#125; &#125; 输出字节流OutputStreamOutputStream 是所有的输出字节流的父类，它是一个抽象类。ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。 示例： 1234567891011121314151617181920File file=new File("F:\\filetest\\a.txt"); FileInputStream fis=null; //写入磁盘 FileOutputStream fos=null; try &#123; fos = new FileOutputStream(file); String str="中华人民共和国"; byte[] b=str.getBytes(); fos.write(b,0,b.length); fos.write(555); fos.write(b,3,15); &#125; catch (Exception e) &#123; &#125;finally &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; &#125; &#125; 字符输入流ReaderReader 是所有的输入字符流的父类，它是一个抽象类。 CharReader、StringReader是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。 InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。 示例： 1234567891011121314File file=new File("F:\\filetest\\b.txt"); FileReader fr=null; try &#123; fr=new FileReader(file); int b; char[] cbuf=new char[50]; while((b=fr.read(cbuf))!=-1) &#123; //System.out.print((char)b); System.out.print(new String(cbuf,0,b)); fr.close(); &#125; &#125; catch (Exception e) &#123; e.getStackTrace(); &#125; 字符输出流WriterWriter 是所有的输出字符流的父类，它是一个抽象类。 CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。 PipedWriter 是向与其它线程共用的管道中写入数据， 示例： 123456789101112131415File file1=new File(&quot;F:\\filetest\\b.txt&quot;); try &#123; FileWriter fw = new FileWriter(file1); String string=&quot;中华人民共和国&quot;; char charray[]=string.toCharArray(); fw.write(charray); fw.write(&apos;\r&apos;); fw.write(66666); fw.write(&quot;中和共和国&quot;); fw.flush();//这个方法不是关闭流，有什么作用: fw.close(); &#125; catch (Exception e) &#123; &#125; 字节缓冲流构造方法： public BufferedInputStream(InpuStream in):创建一个新的缓冲输入流 public BufferedOutputStream(OupuStream out):创建一个新的缓冲输出流 示例： 1234567891011121314public static void bufferdIOStream() throws Exception &#123;BufferedInputStream fis=new BufferedInputStream(new FileInputStream("F:\\filetest\\jdk-8u181-windows-x64.exe"));BufferedOutputStream fos=new BufferedOutputStream(new FileOutputStream("E:\\"));//读数据int b;long start=System.currentTimeMillis();while ((b=fis.read())!=-1) &#123; fos.write(b);&#125;long end=System.currentTimeMillis();System.out.println("结束时间："+end);System.out.println("执行时间："+((end-start)/1000)+"s"); &#125; 字符缓冲流构造方法： BufferedReader br=new BufferedReader(new FileReader(&quot;&quot;)):创建一个新的缓冲输入流 BufferedWriter bw=new BufferedWriter(new FileWriter(&quot;&quot;)):创建一个新的缓冲输出流 示例： 123456789101112public class Buffer_StringStream &#123; public static void buffer_RW() throws Exception&#123; BufferedReader br=new BufferedReader(new FileReader("")); BufferedWriter bw=new BufferedWriter(new FileWriter("")); String line=null; while((line=br.readLine())!=null) &#123; System.out.print(line); System.out.println("-----------"); bw.write(line); &#125; br.close(); &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归递归是指在当前方法内调用自己的这种现象 分类 直接递归：方法自身调用自己 间接递归：从A方法调用B方法，B方法调用C方法，C方法调用A方法 注意 递归一定要有条件限制，保证递归能够停止下来，否则会发生栈内存溢出 在递归中虽然有条件限制，但是递归次数不能太多，否则也会发生栈内存溢出 构造方法禁止递归 例子，打印多级目录 123456789101112131415161718192021222324public static void main(String[] args) &#123; printDir(new File("d:\\jdk1.8")); &#125; public static void printDir(File dir) &#123; File[] dFiles = dir.listFiles(); if (null == dFiles || dFiles.equals(null)) return;// 判断是否为空 for (File file : dFiles) &#123; if (file.isFile()) &#123; System.out.println("文件名绝对路径" + file.getAbsolutePath()); System.out.println("文件名" + file.getName()); // 文件大小 long filesize = file.length(); System.out.println(filesize + "byte" + filesize / 1024 + "kb" + "," + filesize / 1024 / 1024 + "m");// 字节 String exstr = file.getName().substring(file.getName().lastIndexOf(".") + 1, file.getName().length()); System.out.println("拓展名：" + exstr); &#125; else if (file.isDirectory()) &#123; System.out.println("目录名绝对路径" + file.getAbsolutePath()); System.out.println("目录名" + file.getName()); printDir(file); &#125; &#125; &#125; 打印出1-100的和 123456789101112131415public static void main(String[] args) &#123; funSum(1); System.out.println("sum="+sum);&#125;private static int sum = 0;public static void funSum(int i) &#123; sum += i; System.out.println("i=" + i); // 保证递归能够停下来，递归要有限制条件，否则会发生内存溢出 if (i == 100) &#123; return; &#125; i++; funSum(i);&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[File类]]></title>
    <url>%2F2019%2F07%2F24%2FFile%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[File类java.io.file类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找、和删除等操作 构造方法 public File(String pathname):通过将给定的路径名字符串转化为抽象路径名来创建新的File实例 public File(String parent,String child):从父路径名字字符串和子路径名字字符串创建新的File实例 public File(File parent,Stirng child):从抽象父路径名和子路径名字符串创建新的File实例 常用方法 获取功能的方法 public String getAbsoulutePath(): 返回此File的绝对路径名字字符串 public String getPath(): 将此File转换为路径名字字符串 public String getName(): 返回由此File表示的文件目录的名称 public long length() 返回由此File表示的文件的长度 判断功能的方法 public boolean exists(): 此File表示的文件或者目录是否实际存在 public boolean isDirectory(): 此File表示的是否为目录 public boolean isFile(): 此File表示的是否为文件 创建删除文件的功能 public boolean createNewFile(): 当且仅当有该名称的文件存在是，创建一个新的空文件 public boolean delete(): 删除由此File表示的文件或者目录 public boolean mkdir(): 创建由此File表示的目录 public boolean mkdirs(): 创建由此File表示的目录，包括任何必须但不存在的父目录 目录的遍历1234567891011121314151617File dDri = new File("d:\\jdk1.8"); // 获取当前目录下的文件夹和文件夹名称String[] dirs = dDri.list();for (String string : dirs) &#123; // 判断是文件或者目录，参数要用绝对路径 File file = new File(dDri.getAbsoluteFile() + "\\" + string); if (file.isDirectory()) System.out.println(string + "是目录"); else System.out.println(string + "是文件"); &#125;// 获取当前目录下的文件信息(包含目录和文件的完整目录信息)System.out.println("---------------------------------------");File[] dFiles = dDri.listFiles();for (File file : dFiles) &#123; System.out.println(file);&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B3%9B%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[泛型解决了向上向下转型带来的安全隐患，约束了参数的类型，在定义类的时候，对于类属性名，方法的参数不用指明哪一种参数，在使用的时候定义 关键字 通配符但我们使用泛型的时候，对于数据类型，在使用的时候无法确定，使用多种类型的时候，方法的重载搞不定，重载与泛型的重载类型不相关，在重载解决不了的时候，引出 泛型接口泛型接口是在定义时能够接受任何类型的接口，子类可以是一个泛型类，也可以是普通类；如果是普通类要指明实现接口的数据类型；使用泛型接口的时候，如果是普通类，则不能任意改变其泛型接口的类型 实例： 12345678910111213141516171819202122232425262728293031//定义一个泛型接口interface IMessage&lt;T&gt;&#123; //抽象方法 public abstract void print(T t);&#125;//在子类继续定义泛型class MessageImpl&lt;T&gt; implements IMessage&lt;T&gt;&#123; @Override public void print(T t) &#123; System.out.println(t); &#125;&#125;//子类不设置泛型，而在接口处直接实现具体泛型类型class MessageImpl2 implements IMessage&lt;String&gt;&#123; @Override public void print(String t) &#123; System.out.println(t); &#125;&#125;//main方法测试public class GInterface &#123; public static void main(String[] args) &#123; IMessage&lt;String&gt; ii= new MessageImpl &lt;String&gt;(); //泛型接口，子类实现出可以改变数据类型 IMessage&lt;Integer&gt; ii3= new MessageImpl &lt;Integer&gt;(); ii3.print(23); ii.print("hello world"); IMessage&lt;String&gt; ii2 = new MessageImpl2(); ii2.print("hello world"); &#125; 泛型接口使得我们的方法变得通用 泛型的上限下限 【类和方法】设置泛型上限（？extends类）：只能使用当前类的子类是指泛型类型；如：“？extends Number:可以设置Number或Number的子类，如double不能设置String 【方法】设置泛型下限（？ super类）：只能使用指定类或者父类设置泛型类型；如：“？ super String”:只能使用String类或Objects设置泛型类型 12345678910111213//【类和方法】设置泛型上限class Message1&lt;T extends Number&gt;&#123; private T msg; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; public void fun(Message1&lt;? extends Number&gt; temp) &#123; System.out.println(temp.getMsg()); &#125;&#125; 1234567891011121314//【方法】设置泛型上限class Message2&lt;T&gt;&#123; private T msg; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; //设置泛型下限 public void fun(Message2&lt;? super String&gt; temp) &#123; System.out.println(temp.getMsg()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射1.概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象，（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述） 2.使用2.1反射Class的使用:获取Class的三种方式 Object ——&gt;getClass()，即通过对象.getClass Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取 任何数据类型（包括基本数据类型）都有一个“静态的方法”的Class属性 通过Class类的静态方法：forName(String className)(常用) 示例： 12345678910111213//先定义一个Student类class Student&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; void testPring() &#123; System.out.println(""); &#125;&#125; 通过Object获得对象 1234Student stuObj = new Student();//产生一个student对象Class&lt;? extends Student&gt; stuClass = stuObj.getClass();System.out.println(stuClass.getName());//完整类型名System.out.println(stuClass.getSimpleName());//简单类型名 通过静态Class属性获得 1234Class&lt;?&gt; cls = cn.cuit.reflanctence.Student.class;System.out.println("全名"+cls.getName());System.out.println("类型名"+cls.getSimpleName());System.out.println(stuClass == cls);//判断第一种方式获取的class对象 通过Class类的静态方法 12345678910try &#123; Class&lt;Student&gt; stu = (Class&lt; Student&gt;) Class.forName("cn.cuit.reflanctence.Student"); //通过Class类的newinstance()可以得到对象 Student stuobj1 = stu.newInstance(); stuobj1.setName("张三"); stuobj1.testPring(); System.out.println(stuobj1.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 反射实例化对象 12345Class&lt;Student&gt; stu = (Class&lt; Student&gt;) Class.forName("cn.cuit.reflanctence.Student"); //通过Class类的newinstance()可以得到对象 Student stuobj1 = stu.newInstance(); stuobj1.setName("张三"); stuobj1.testPring(); 注意：在运行期间，一个类，只有一个Class对象产生。 三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 2.2反射调用构造方法利用反射器调用构造方法需要类中有默认构造方法，如果没有默认构造方法则需要通过反射调用指定类型的参数构造，实现实例化 Apple类 123456789101112131415161718192021222324252627282930313233343536class Apple&#123; private String name; private Integer weight; //封装 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; //默认构造 public Apple() &#123;&#125; //带参构造 public Apple(String name,Integer weight) &#123; this.name=name; this.weight=weight; &#125; @Override public String toString() &#123; return "Apple [name=" + name + ", weight=" + weight + "]"; &#125; //定义一个不带参的方法 public void print() &#123; System.out.println("苹果"+this.name+"重量是"+this.weight); &#125; //定义一个带参的方法 public void prin1t(String name,int weight) &#123; System.out.println("苹果"+this.name+"重量是"+this.weight); &#125;&#125; 测试类 1234567891011public class TestRef &#123; public static void main(String[] args) throws Exception &#123; //Class的类的实例调用getConstrcutor()取得类的构造器 Class&lt;?&gt; class1 = Class.forName("cn.cuit.ref.Apple"); //利用反射调用自定义构造方法 Constructor&lt;?&gt; ct = class1.getConstructor(String.class, Integer.class); //构造器.newinstance()取得具体的对象 Apple aplObj = (Apple) ct.newInstance("红富士", 20); System.out.println(aplObj); &#125;&#125; 结果： 1Apple [name=红富士, weight=20] 2.3反射调用普通方法12345678910//获取Class对象Class&lt;?&gt; cls = Class.forName("cn.cuit.ref.Apple");//获取不带参的print方法Method printMethod = cls.getMethod("print");//相当于调用方法printprintMethod.invoke(cls.newinstance);//获取带参的print1方法Method printMethod1 = cls.getMethod("print1",String.class,int.class);//调用带参的普通方法printMethod1.invoke(cls.newinstance,"sss",666) 2.4反射取得类成员类的成员包括： 从其他类继承而来的成员：public Field getField 本类中定义的成员：public Field getDeclareField 12345678910111213141516171819202122public class TestRef3 &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName("cn.cuit.reflanctence.Apple"); Object object = cls.newInstance(); Field field =cls.getDeclaredField("name"); /////////////////////////////////// Field[] fields = cls.getFields(); for(int i = 0 ; i &lt;fields.length;i++) &#123; System.out.println(fields[i].getName()); &#125; ///////////////////////////////////// //解除类成员变量的private的访问权限 field.setAccessible(true); //给对象赋值 field.set(object, "红苹果"); //取得对象属性的值 field.get(object); Method method =cls.getDeclaredMethod("print"); method.invoke(object); &#125;&#125; 使用declare的优点 2.6反射改造工厂12345678910111213141516171819202122232425262728293031323334353637383940414243//定义一个接口interface ILearn&#123; public abstract void learn();&#125;class Student implements ILearn&#123; @Override public void learn() &#123; System.out.println("学生在上课"); &#125;&#125;class Teacher implements ILearn&#123; @Override public void learn() &#123; System.out.println("老师在备课"); &#125;&#125;class Works implements ILearn&#123; @Override public void learn() &#123; System.out.println("工人在干工"); &#125;&#125;class SimpleFactory&#123; //创建对象 public static ILearn createInstance(String className) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(className); return(ILearn)cls.newInstance(); &#125;&#125;public class TestRefFactory &#123; public static void main(String[] args) &#123; ILearn stuZs = new Student(); stuZs.learn(); ILearn teLS = new Teacher(); teLS.learn(); ILearn wuWU = new Works(); wuWU.learn(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境配置]]></title>
    <url>%2F2019%2F07%2F21%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Windows上安装Java环境下载JDK及安装 首先首先我们需要下载java开发工具包JDK，下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html，点击如下下载按钮： 在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本，本文以 Window64位系统为例： 下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。 安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 C:\Program Files (x86)\Java\jdk1.8.0_91。 配置环境变量 安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”； 选择”高级”选项卡，点击”环境变量”； 然后就会出现如下图所示的画面：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals方法重写]]></title>
    <url>%2F2019%2F07%2F21%2Fequals%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重写equals方法equals方法也是object类中的一个方法，调用object类就可以找到，是一个boolean类型的方法，用于比较两个对象是否相等 代码演示 123456789101112public boolean equals(Object obj) &#123; //判断对象地址是否相等，如果是就不用判断 if(this == obj) &#123; return false; &#125; 判断对象是否为空以及两个对象是否相等 if(obj == null || this.getClass() != obj.getClass()) &#123; return true; &#125; Equels equels = (Equels) obj; //判断成员变量 return age ==equels.age &amp;&amp; Objects.equals(getName(), equels.getName())]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
