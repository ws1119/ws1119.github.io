<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B3%9B%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[泛型解决了向上向下转型带来的安全隐患，约束了参数的类型，在定义类的时候，对于类属性名，方法的参数不用指明哪一种参数，在使用的时候定义 关键字 通配符但我们使用泛型的时候，对于数据类型，在使用的时候无法确定，使用多种类型的时候，方法的重载搞不定，重载与泛型的重载类型不相关，在重载解决不了的时候，引出 泛型接口泛型接口是在定义时能够接受任何类型的接口，子类可以是一个泛型类，也可以是普通类；如果是普通类要指明实现接口的数据类型；使用泛型接口的时候，如果是普通类，则不能任意改变其泛型接口的类型 实例： 12345678910111213141516171819202122232425262728293031//定义一个泛型接口interface IMessage&lt;T&gt;&#123; //抽象方法 public abstract void print(T t);&#125;//在子类继续定义泛型class MessageImpl&lt;T&gt; implements IMessage&lt;T&gt;&#123; @Override public void print(T t) &#123; System.out.println(t); &#125;&#125;//子类不设置泛型，而在接口处直接实现具体泛型类型class MessageImpl2 implements IMessage&lt;String&gt;&#123; @Override public void print(String t) &#123; System.out.println(t); &#125;&#125;//main方法测试public class GInterface &#123; public static void main(String[] args) &#123; IMessage&lt;String&gt; ii= new MessageImpl &lt;String&gt;(); //泛型接口，子类实现出可以改变数据类型 IMessage&lt;Integer&gt; ii3= new MessageImpl &lt;Integer&gt;(); ii3.print(23); ii.print("hello world"); IMessage&lt;String&gt; ii2 = new MessageImpl2(); ii2.print("hello world"); &#125; 泛型接口使得我们的方法变得通用 泛型的上限下限 【类和方法】设置泛型上限（？extends类）：只能使用当前类的子类是指泛型类型；如：“？extends Number:可以设置Number或Number的子类，如double不能设置String 【方法】设置泛型下限（？ super类）：只能使用指定类或者父类设置泛型类型；如：“？ super String”:只能使用String类或Objects设置泛型类型 12345678910111213//【类和方法】设置泛型上限class Message1&lt;T extends Number&gt;&#123; private T msg; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; public void fun(Message1&lt;? extends Number&gt; temp) &#123; System.out.println(temp.getMsg()); &#125;&#125; 1234567891011121314//【方法】设置泛型上限class Message2&lt;T&gt;&#123; private T msg; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; //设置泛型下限 public void fun(Message2&lt;? super String&gt; temp) &#123; System.out.println(temp.getMsg()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射1.概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象，（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述） 2.使用2.1反射Class的使用:获取Class的三种方式 Object ——&gt;getClass()，即通过对象.getClass Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取 任何数据类型（包括基本数据类型）都有一个“静态的方法”的Class属性 通过Class类的静态方法：forName(String className)(常用) 示例： 12345678910111213//先定义一个Student类class Student&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; void testPring() &#123; System.out.println(""); &#125;&#125; 通过Object获得对象 1234Student stuObj = new Student();//产生一个student对象Class&lt;? extends Student&gt; stuClass = stuObj.getClass();System.out.println(stuClass.getName());//完整类型名System.out.println(stuClass.getSimpleName());//简单类型名 通过静态Class属性获得 1234Class&lt;?&gt; cls = cn.cuit.reflanctence.Student.class;System.out.println("全名"+cls.getName());System.out.println("类型名"+cls.getSimpleName());System.out.println(stuClass == cls);//判断第一种方式获取的class对象 通过Class类的静态方法 12345678910try &#123; Class&lt;Student&gt; stu = (Class&lt; Student&gt;) Class.forName("cn.cuit.reflanctence.Student"); //通过Class类的newinstance()可以得到对象 Student stuobj1 = stu.newInstance(); stuobj1.setName("张三"); stuobj1.testPring(); System.out.println(stuobj1.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 反射实例化对象 12345Class&lt;Student&gt; stu = (Class&lt; Student&gt;) Class.forName("cn.cuit.reflanctence.Student"); //通过Class类的newinstance()可以得到对象 Student stuobj1 = stu.newInstance(); stuobj1.setName("张三"); stuobj1.testPring(); 注意：在运行期间，一个类，只有一个Class对象产生。 三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 2.2反射调用构造方法利用反射器调用构造方法需要类中有默认构造方法，如果没有默认构造方法则需要通过反射调用指定类型的参数构造，实现实例化 Apple类 123456789101112131415161718192021222324252627282930313233343536class Apple&#123; private String name; private Integer weight; //封装 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; //默认构造 public Apple() &#123;&#125; //带参构造 public Apple(String name,Integer weight) &#123; this.name=name; this.weight=weight; &#125; @Override public String toString() &#123; return "Apple [name=" + name + ", weight=" + weight + "]"; &#125; //定义一个不带参的方法 public void print() &#123; System.out.println("苹果"+this.name+"重量是"+this.weight); &#125; //定义一个带参的方法 public void prin1t(String name,int weight) &#123; System.out.println("苹果"+this.name+"重量是"+this.weight); &#125;&#125; 测试类 1234567891011public class TestRef &#123; public static void main(String[] args) throws Exception &#123; //Class的类的实例调用getConstrcutor()取得类的构造器 Class&lt;?&gt; class1 = Class.forName("cn.cuit.ref.Apple"); //利用反射调用自定义构造方法 Constructor&lt;?&gt; ct = class1.getConstructor(String.class, Integer.class); //构造器.newinstance()取得具体的对象 Apple aplObj = (Apple) ct.newInstance("红富士", 20); System.out.println(aplObj); &#125;&#125; 结果： 1Apple [name=红富士, weight=20] 2.3反射调用普通方法12345678910//获取Class对象Class&lt;?&gt; cls = Class.forName("cn.cuit.ref.Apple");//获取不带参的print方法Method printMethod = cls.getMethod("print");//相当于调用方法printprintMethod.invoke(cls.newinstance);//获取带参的print1方法Method printMethod1 = cls.getMethod("print1",String.class,int.class);//调用带参的普通方法printMethod1.invoke(cls.newinstance,"sss",666) 2.4反射取得类成员类的成员包括： 从其他类继承而来的成员：public Field getField 本类中定义的成员：public Field getDeclareField 12345678910111213141516171819202122public class TestRef3 &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName("cn.cuit.reflanctence.Apple"); Object object = cls.newInstance(); Field field =cls.getDeclaredField("name"); /////////////////////////////////// Field[] fields = cls.getFields(); for(int i = 0 ; i &lt;fields.length;i++) &#123; System.out.println(fields[i].getName()); &#125; ///////////////////////////////////// //解除类成员变量的private的访问权限 field.setAccessible(true); //给对象赋值 field.set(object, "红苹果"); //取得对象属性的值 field.get(object); Method method =cls.getDeclaredMethod("print"); method.invoke(object); &#125;&#125; 使用declare的优点 2.6反射改造工厂12345678910111213141516171819202122232425262728293031323334353637383940414243//定义一个接口interface ILearn&#123; public abstract void learn();&#125;class Student implements ILearn&#123; @Override public void learn() &#123; System.out.println("学生在上课"); &#125;&#125;class Teacher implements ILearn&#123; @Override public void learn() &#123; System.out.println("老师在备课"); &#125;&#125;class Works implements ILearn&#123; @Override public void learn() &#123; System.out.println("工人在干工"); &#125;&#125;class SimpleFactory&#123; //创建对象 public static ILearn createInstance(String className) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(className); return(ILearn)cls.newInstance(); &#125;&#125;public class TestRefFactory &#123; public static void main(String[] args) &#123; ILearn stuZs = new Student(); stuZs.learn(); ILearn teLS = new Teacher(); teLS.learn(); ILearn wuWU = new Works(); wuWU.learn(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境配置]]></title>
    <url>%2F2019%2F07%2F21%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Windows上安装Java环境下载JDK及安装 首先首先我们需要下载java开发工具包JDK，下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html，点击如下下载按钮： 在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本，本文以 Window64位系统为例： 下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。 安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 C:\Program Files (x86)\Java\jdk1.8.0_91。 配置环境变量 安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”； 选择”高级”选项卡，点击”环境变量”； 然后就会出现如下图所示的画面：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals方法重写]]></title>
    <url>%2F2019%2F07%2F21%2Fequals%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重写equals方法equals方法也是object类中的一个方法，调用object类就可以找到，是一个boolean类型的方法，用于比较两个对象是否相等 代码演示 123456789101112public boolean equals(Object obj) &#123; //判断对象地址是否相等，如果是就不用判断 if(this == obj) &#123; return false; &#125; 判断对象是否为空以及两个对象是否相等 if(obj == null || this.getClass() != obj.getClass()) &#123; return true; &#125; Equels equels = (Equels) obj; //判断成员变量 return age ==equels.age &amp;&amp; Objects.equals(getName(), equels.getName())]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
